/*
	tab width set to 3 spaces
*/

/* POD documentation

=head1 NAME

temp_update_temps.exe - For both the input files, B<temp_update_temps.exe> produces a new output file with some missing data points filled in.

=head1 SYNOPSIS

temp_update_temps.exe TEMPORARY-DIR DATE DAM1 [DAM2 [...]]

=head1 DESCRIPTION

The F<query_results.DAM.year> file is described in B<temp_output.exe>.
F<newflow.DAM> is an Ingres report generated by temps.pl using flow.rpt
with the the julian day in the first column and the outflow in the
second.

B<temp_update_temps.exe> processes the data in F<query_results.DAM.YEAR>
and F<newflow.DAM> very similiarly.   It makes sure each data point is within
a valid range and discards the point if it isn't, then fills in any
missing data points with guesses based on the nearest valid days.
The output contains data for day 1 through the last day of observed data.

=head1 How missing data points are filled in

=over

=item * Missing leading data points

It fills in the missing data points from 1/1/YEAR to the first day of
valid data by just assigning the whole range the value from the first
day of valid data.

=item * Holes in data points 

Holes between valid data points are linearly interpolated between the
two surrounding data points. 

=back

=head1 INPUT FILES

   TEMPORARY-DIR/query_results.DAM.YEAR (from sreport)
   TEMPORARY-DIR/newflow.DAM (from sreport)

=head1 OUTPUT FILES

   TEMPORARY-DIR/tempDAM.YEAR
   TEMPORARY-DIR/flowDAM.YEAR

=cut

*/

/* update_temps.c:  Because there could be bogus data points in DART,
some data points in tempDAM.YR or flowDAM.YR may be changed.  The point
of this program is to keep the old temp and flow data files and just
update the most current data from Ingres. This prevents a constant
re-changing of a currently non-standardized process of evaluatiing
bogus data.	 */

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

#define USAGE "Usage:  temp_update_temps.exe temp_directory year\n"
#define PROGNAME "temp_update_temps.exe"
 
#define MAXFILENAME 100
#define MAXLINE 500
/* Need to define BACKCASTFLAG with the same value in temp_r.c also. */
#define  BACKCASTFLAG 101.0

void abort_run()
/* This function aborts program run */
{
		  extern void exit();
 
		  fprintf(stderr, "%s: Aborting Run... \n", PROGNAME);
			 exit(1);
}
 
void check_file(filename,fptr)
char *filename;
FILE *fptr;
/* Returns error if couldn't open file: filename */
{
		  if(fptr==0) {
					 printf("error, Can't open %s \n",filename);
					 abort_run();
		  }
		  else {
					 printf("Opened file %s \n", filename);
		  }
}

int valid_temp(tempc)
float tempc;
/* Returns 1 if tempc is a valid value for river temp in celcius;
	otherwise returns 0
	This procedure rules out absurd values, however does allow
	for some pretty extreme values of temp not observed in 
	recent history on mainstem columbia and snake rivers.
	However, may be realistic for future, more shallow headwater
	temperatures.
*/
{
	if( (tempc<0.5) || ( (tempc>=32) && (tempc!=BACKCASTFLAG) ) )
		return(0);
	else
		return(1);

}

int valid_flow(flow)
float flow;
/* Returns 1 if flow is a valid value for river kcfs;
	otherwise returns 0
	This procedure rules out absurd values, however does allow
	for very extreme values of flow not observed in
	recent history on mainstem columbia and snake rivers.
	However, may be realistic for future, more shallow headwater
	flows.
*/
{
		  if( (flow<2) || (flow>=600) )
					 return(0);
		  else
					 return(1);
 
}

/* reads a file full of names and reads the names into the character array
	list.	 This function returns the length of the list n.
*/
int read_station_list(char **array, int num, char list[100][MAXLINE])
{
	int	n;
	
	/*
		I don't know why the original author has it starting
		at 1 instead of 0, but I'll stay with it so I don't
		have to modify any more code.	  So we'll waste a word...
	*/
	for(n = 1 ; n <= num && n < 100 ; n++)
	{
		strcpy(&list[n][0], array[n-1]); 
	}

	if(n == 100)
	{
		fprintf(stderr, "Max number of stations exceeded\n");
	}

	return num;
}

int main(int argc, char **argv)
{
	char	temperature_output[MAXFILENAME],
			flow_output[MAXFILENAME],
			temperature_input[MAXFILENAME],
			flow_input[MAXFILENAME],
			dams[100][MAXLINE],
			stn[100][MAXLINE],
			foo[MAXLINE],
			*temp_dir;
	FILE	*tnew_fptr,
			*temp_fptr,
			*fnew_fptr,
			*flow_fptr;
	float	temp,
			flow,
			dif,
			tvec[367],
			fvec[367];
	int	YEAR,
			i,
			n,
			num_stn,
			num_dam,
			day,da,
			d_aft,
			d_bef,
			julian,
			firstday,
			lastday,
			nval_temps,
			nval_flows;

	if(argc < 4)
	{
		fprintf(stderr, "%s", USAGE);
		return 1;
	}
	temp_dir = argv[1];

	errno = 0;
	YEAR = strtol(argv[2], (char**)NULL, 10);
	if(YEAR == 0 || errno != 0)
	{
		fprintf(stderr, "temp_update_temps.exe error, converting year to an integer: %s\n", argv[2]);
		return 1;
	}

	/* modifying code...	  SO lazy! */
	num_stn=read_station_list(argv + 3, argc - 3, dams);
	num_dam=read_station_list(argv + 3, argc - 3, stn);	
	if(!(num_stn==num_dam)){
		printf("temp_update_temps.exe: error in dam or station list! \n");
		abort_run();
	}


	/*
		check length of longest filename is less than MAXFILENAME
		%s/query_results.DAM.YEAR
		%s/tempDAM.YEAR
		%s/newflow.DAM
		%s/flowDAM.YEAR
	*/
	i = strlen(temp_dir) + strlen("/query_results.DAM.YEAR\0");
	if(i > MAXFILENAME)
	{
		fprintf(stderr, "temp_update_temps.exe:  Error, max filename length exceeded, make MAXFILENAME longer\n");
		abort_run();
	}


	/*	Note:	the body of this for(;;){} loop is split into 
				two very similiar sections that almost are duplicates
				of each other.
	*/
	for(i=1; i<=num_dam; i++)
	{
		sprintf(temperature_input, "%s/query_results.%s.%d", temp_dir, stn[i], YEAR);
		sprintf(temperature_output, "%s/temp%s.%d", temp_dir, dams[i], YEAR);

		sprintf(flow_input, "%s/newflow.%s", temp_dir, dams[i]);
		sprintf(flow_output, "%s/flow%s.%d", temp_dir, dams[i], YEAR);

		/* Initializations for new temperature data */
	
		lastday = 0;
		firstday=0;
		for(day=0; day<=366; day++)
		{
			tvec[day] = -9.0;
		}
	
	
		/* Open New temperature data */

		tnew_fptr = fopen(temperature_input, "r");
		check_file(temperature_input,tnew_fptr);

		fgets(foo,MAXLINE,tnew_fptr);
		fgets(foo,MAXLINE,tnew_fptr);
		fgets(foo,MAXLINE,tnew_fptr);

		nval_temps=0;
		while( ((fscanf(tnew_fptr, "%d %f ", &julian,&temp)) !=EOF )) 
		{
			if(firstday==0)
			{
				 firstday = julian;
			}
			if(valid_temp(temp)==1)
			{
				 lastday = julian;
			}

			tvec[julian] = temp;
			/* printf("tvec[%d] = %f \n",julian,temp); */

			if(valid_temp(temp)==1)
			{
				nval_temps++;
			}
		}
	
		fclose(tnew_fptr);
		printf("lastday=%d\n",lastday);

		/* Data filling in and screening for absurd river temperture values */
		if((nval_temps > 0) && (firstday != lastday))
		{
			/* If 'firstday' is not valid, then find the first valid day and
			 * set all days from 'firstday' to the first valid day to the value
			 * of the first valid day. */
			if(valid_temp(tvec[firstday]) == 0) 
			{
				d_aft = firstday + 1;
				while((valid_temp(tvec[d_aft])==0) && (d_aft<lastday) )
				{
					d_aft++;
				}
				for(day = firstday; day< d_aft; day++)
				{
				    /*tvec[day] = tvec[d_aft];  old flatline backCast  */
				    tvec[day] = BACKCASTFLAG;
				}
			}
			/* Now fill in days 1 through 'firstday' with the value of 'firstday' */
			for(day=1; day<firstday; day++)
			{
			    /*	tvec[day] = tvec[firstday]; old flatline backCast */
			    /* NEW DS2002.    */
			    tvec[day] = BACKCASTFLAG;
			}

			/* Same story as the first if() in this block.
			 * If 'lastday' is invalid, then find the last day of valid data
			 * and fill in all days from that day to 'lastday' with the value
			 * of the last day of valid data. */
			if(valid_temp(tvec[lastday])==0 ) 
			{
				d_bef = lastday - 1;
				while((valid_temp(tvec[d_bef])==0) && (d_bef>firstday) )
				{
					d_bef--;
				}
				for(day = lastday; day>d_bef; day--)
				{
					tvec[day] = tvec[d_bef];
				}
			}
			
	
			/* Now find any holes in the data between 'firstday' and 'lastday'
			 * and fill in those holes by plotting a line between the data
			 * point on each side of the hole in the data. */
			da = firstday+1;
			while (da < lastday)
			{
				if(valid_temp(tvec[da])==0) 
				{
					d_bef = da-1;
					d_aft = da+1;
					while((valid_temp(tvec[d_aft])==0) &&(d_aft<lastday) ) 
					{
						d_aft++;
					}
					dif = tvec[d_aft] - tvec[d_bef];
					n = d_aft - d_bef;
					for(day= da; day<=d_aft; day++)
					{
						tvec[day] = tvec[day-1] + dif/n;
					}
					da= d_aft;
				}
				da++;	
			}
		}



		/* no valid data scanned in, this ensures bad data 
			flagged with -9 and not other invalid scanned in values 
		*/
		if(valid_temp(tvec[firstday]==0) )
		{
			for(da=firstday; da<=lastday; da++)
			{
				tvec[da] = -9.0;
			}
		}

		/* Create new Temperature data file */

		temp_fptr = fopen(temperature_output,"w");
		check_file(temperature_output, temp_fptr);
		for(day=1; day<=lastday; day++)
		{
			fprintf(temp_fptr,"%d %.2f \n", day,tvec[day]);
		}
		fclose(temp_fptr);

		
		/****** Done processing temperature data, now processing flow data *****/

		/* Initializations for new flow data */
	
		lastday = 0;
		firstday=0;
		for(day=0; day<=366; day++)
		{
			fvec[day] = -9.0;
		}

		/* Open New Flow data */

		fnew_fptr = fopen(flow_input, "r");
		check_file(flow_input,fnew_fptr);

		fgets(foo,MAXLINE,fnew_fptr);
		fgets(foo,MAXLINE,fnew_fptr);
		fgets(foo,MAXLINE,fnew_fptr);

		nval_flows=0;
		while( ((fscanf(fnew_fptr, "%d %f ", &julian,&flow)) !=EOF )) 
		{
			if(firstday==0)
			{
				 firstday = julian;
			}
			lastday = julian;

			fvec[julian] = flow;
			/* printf("fvec[%d] = %f \n",julian,flow); */

			if(valid_flow(flow)==1)
			{
				nval_flows++;
			}
		}

		fclose(fnew_fptr);


	/* Data filling in and screening for absurd river flow values */
	
		if( (nval_flows>0) && (firstday!=lastday) )
		{
			/* The comments in the if() block for temperature above apply
			 * to this block also. */

			if(valid_flow(fvec[firstday])==0) 
			{
				d_aft = firstday + 1;
				while((valid_flow(fvec[d_aft])==0) && (d_aft<lastday) )
				{
					d_aft++;
				}
				for(day = firstday; day< d_aft; day++)
				{
					fvec[day] = fvec[d_aft];
				}
			}

			for(day=1; day<firstday; day++)
			{
				fvec[day] = fvec[firstday];
			}

			if(valid_flow(fvec[lastday])==0 ) 
			{
				d_bef = lastday - 1;
				while((valid_flow(fvec[d_bef])==0) && (d_bef>firstday) )
				{
					d_bef--;
				}
				for(day = lastday; day>d_bef; day--)
				{
					fvec[day] = fvec[d_bef];
				}
			}
		

			da = firstday+1;
			while (da<lastday)
			{

				if(valid_flow(fvec[da])==0) 
				{
					d_bef = da-1;
					d_aft = da+1;
					while((valid_flow(fvec[d_aft])==0) &&(d_aft<lastday) ) 
					{
						d_aft++;
					}
					dif = fvec[d_aft] - fvec[d_bef];
					n = d_aft - d_bef;
					for(day= da; day<=d_aft; day++)
					{
						fvec[day] = fvec[day-1] + dif/n;
					}
					da= d_aft;
				}
				da++;	
			 }
		}

		/* no valid data scanned in, this ensures bad data 
		flagged with -9 and not other invalid scanned in values 
		*/
		if(valid_flow(fvec[firstday]==0) )
		{
			for(da=firstday; da<=lastday; da++)
			{
				fvec[da] = -9.0;
			}
		}

		/* Create new Flowerature data file */

		flow_fptr = fopen(flow_output,"w");
		check_file(flow_output,flow_fptr);
		for(day=1; day<=lastday; day++)
		{
			fprintf(flow_fptr,"%d	%8.2f \n", day,fvec[day]);
		}
		fclose(flow_fptr);
	}

				
	return 0;
}
